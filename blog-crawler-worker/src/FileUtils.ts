import type { ScrapedBlog } from './BlogScraper';
import { BrowserImageGenerator, type GeneratedImage } from './BrowserImageGenerator';

/**
 * FileUtils - Handles file operations and KV storage
 */

export interface DispatchResult {
	success: boolean;
	filename?: string;
	path?: string;
	imageGenerated: boolean;
	imageFilename?: string;
	imagePath?: string;
	error?: string;
}

export class FileUtils {
	private kvNamespace: KVNamespace;
	private repoOwner: string;
	private repoName: string;
	private githubToken: string;
	private imageGenerator: BrowserImageGenerator;

	constructor(
		kvNamespace: KVNamespace,
		repoOwner: string,
		repoName: string,
		githubToken: string,
		browserBinding: Fetcher,
		graphicsBucket: R2Bucket
	) {
		this.kvNamespace = kvNamespace;
		this.repoOwner = repoOwner;
		this.repoName = repoName;
		this.githubToken = githubToken;
		this.imageGenerator = new BrowserImageGenerator(browserBinding, graphicsBucket);
	}
	async getLastProcessedDate(): Promise<Date> {
		try {
			const lastProcessedIso = await this.kvNamespace.get('LAST_PROCESSED_DATE');
			if (lastProcessedIso) {
				console.log(`üìÖ Last processed date from KV: ${lastProcessedIso}`);
				return new Date(lastProcessedIso);
			}

			// Default to 7 days ago if no previous date stored
			const defaultDate = new Date();
			defaultDate.setDate(defaultDate.getDate() - 7);
			console.log(`üìÖ No previous date found, using default: ${defaultDate.toISOString().split('T')[0]}`);
			return defaultDate;
		} catch (error) {
			console.error('Error getting last processed date:', error);
			// Fallback to 7 days ago
			const fallbackDate = new Date();
			fallbackDate.setDate(fallbackDate.getDate() - 7);
			return fallbackDate;
		}
	}

	async updateLastProcessedDate(date: Date): Promise<void> {
		try {
			await this.kvNamespace.put('LAST_PROCESSED_DATE', date.toISOString());
			console.log(`‚úÖ Updated last processed date to: ${date.toISOString().split('T')[0]}`);
		} catch (error) {
			console.error('Error updating last processed date:', error);
			throw error;
		}
	}

	async githubDispatch(title: string, content: string, scrapedBlog: ScrapedBlog, sourceUrl?: string): Promise<DispatchResult> {
		try {
			console.log(`üöÄ Dispatching to GitHub: ${title}`);

			// FIXED: Encode content as Base64 to prevent shell execution issues
			const contentBase64 = btoa(unescape(encodeURIComponent(content)));

			// Use the AI-chosen category for the path (scrapedBlog.category is now the correct slug)
			const categorySlug = scrapedBlog.category || 'product-update';

			// Generate blog image
			console.log('üé® Generating image for blog post...');
			console.log(`üìÇ Category for image generation: ${categorySlug}`);
			console.log(`üìÑ Blog title: ${title}`);
			console.log(`üìÅ Filename: ${scrapedBlog.filename || 'untitled.mdx'}`);

			let generatedImage: GeneratedImage | null = null;
			try {
				generatedImage = await this.imageGenerator.generateBlogImage(title, categorySlug, scrapedBlog.filename || 'untitled.mdx');

				// Check if image is too large for GitHub API (GitHub has strict payload limits)
				const imageSizeKB = (generatedImage.imageBase64.length / 1024) * 0.75;
				console.log(`üìä Generated image size: ${imageSizeKB.toFixed(0)}KB (base64)`);

				// Be very conservative with GitHub API limits - reduced to 150KB due to 422 errors
				if (imageSizeKB > 150) {
					console.log(`‚ö†Ô∏è  Generated image too large (${imageSizeKB.toFixed(0)}KB) for GitHub API, skipping image`);
					console.log('üí° Image will be generated by GitHub Actions instead');
					generatedImage = null;
				} else {
					console.log(`‚úÖ Image generated successfully: ${generatedImage.filename}`);
				}
			} catch (imageError) {
				console.error('‚ùå Image generation failed with error:', imageError);
				console.error('Error details:', imageError instanceof Error ? imageError.message : 'Unknown error type');
				console.error('Stack trace:', imageError instanceof Error ? imageError.stack : 'No stack trace');
			} // Trigger repository dispatch to publish blog
			const dispatchUrl = `https://api.github.com/repos/${this.repoOwner}/${this.repoName}/dispatches`;

			const payload = {
				event_type: 'publish-blog',
				client_payload: {
					filename: scrapedBlog.filename,
					content_base64: contentBase64, // Send Base64 encoded content
					message: `Add blog post: ${title}`, // Proper commit message instead of whole content!
					path: `docs/pages/${categorySlug}/${scrapedBlog.filename}`, //TODO: Does not handle duplicate
					timestamp: new Date().toISOString(),
					content_length: content.length, // For verification
					source_url: sourceUrl, // Add source URL for reference
					// Image data (if generated successfully)
					image: generatedImage
						? {
								filename: generatedImage.filename,
								path: generatedImage.path,
								content_base64: generatedImage.imageBase64,
						  }
						: null,
				},
			};

			console.log('Sending dispatch with payload:', {
				filename: scrapedBlog.filename,
				content_base64_length: contentBase64.length,
				path: `docs/pages/public/images/blog/${categorySlug}/${scrapedBlog.filename}`,
				image_included: !!generatedImage,
				image_filename: generatedImage?.filename,
			});

			const response = await fetch(dispatchUrl, {
				method: 'POST',
				headers: {
					Authorization: `token ${this.githubToken}`,
					Accept: 'application/vnd.github.v3+json',
					'Content-Type': 'application/json',
					'User-Agent': 'Cloudflare-Pages-Function',
				},
				body: JSON.stringify(payload),
			});

			if (response.status === 204) {
				console.log(`‚úÖ Successfully dispatched to GitHub: ${scrapedBlog.filename}`);
				console.log(`   Repository: ${this.repoOwner}/${this.repoName}`);
				console.log(`   Path: docs/pages/${scrapedBlog.category}/${scrapedBlog.filename}`);
				console.log(`   Content size: ${content.length} characters`);
				console.log(`   Encoded size: ${contentBase64.length} characters`);
				if (generatedImage) {
					console.log(`   Image: ${generatedImage.filename} (${generatedImage.imageBase64.length} chars base64)`);
					console.log(`   Image path: ${generatedImage.path}`);
				} else {
					console.log('   Image: Not generated');
				}

				return {
					success: true,
					filename: scrapedBlog.filename,
					path: `docs/pages/${categorySlug}/${scrapedBlog.filename}`,
					imageGenerated: !!generatedImage,
					imageFilename: generatedImage?.filename,
					imagePath: generatedImage?.path,
				};
			}

			const errorText = await response.text();
			console.error('GitHub API error:', response.status, errorText);
			throw new Error(`GitHub API error: ${response.status} - ${errorText}`);
		} catch (error) {
			console.error(`Error dispatching to GitHub for ${title}:`, error);
			return {
				success: false,
				error: error instanceof Error ? error.message : 'Unknown error',
				imageGenerated: false,
			};
		}
	}
}
